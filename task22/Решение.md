Для примера я приведу рабочий процесс, на деле он далек от правильного ООП, но я как раз занимаюсь чем то вроде параллельного проектирования всей системы в ООП парадигме, настоящей, и тут получается отличный пример. Есть сущность кредитная заявка. По мере прохождения процесса выдачи клиенту кредита, очень многое зависит от типа счета, типа риска, типа стратегии кредитования и т.п. Я все пункты приводить не буду, их более 15 ну и NDA.

Так вот, наследование вида подходит сюда как нельзя лучше, поскольку все признаки важны по мере прохождения зачвки процесса, а применение базовых типов для всех этих признаков погрузит нас ад операторов ветвления (это сейчас не гротеск, на проекте все выглядит именно так). А вот применив к каждому признаку свою собственную иерархию(на деле так и есть, поскольку есть несколько типов счетов + "отсутсвующий" счет), мы вернёмся в лоно ООП и даже сможем избежать ада операторов ветвлениия в бизнес логике.

Код заявки могу бы выглядеть примерно так:
``` Java
class Opportunity {
    private Rko rko;
    private RiskModel riskMdel;
    private Strategy strategy;

    // геттеры и сеттеры
}
```
